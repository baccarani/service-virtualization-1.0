{"version":3,"file":"ngrx-effects.mjs","sources":["../../../../modules/effects/src/models.ts","../../../../modules/effects/src/effect_creator.ts","../../../../modules/effects/src/utils.ts","../../../../modules/effects/src/effect_decorator.ts","../../../../modules/effects/src/effects_metadata.ts","../../../../modules/effects/src/effects_resolver.ts","../../../../modules/effects/src/effects_error_handler.ts","../../../../modules/effects/src/actions.ts","../../../../modules/effects/src/tokens.ts","../../../../modules/effects/src/effects_actions.ts","../../../../modules/effects/src/effect_notification.ts","../../../../modules/effects/src/lifecycle_hooks.ts","../../../../modules/effects/src/effect_sources.ts","../../../../modules/effects/src/effects_runner.ts","../../../../modules/effects/src/effects_root_module.ts","../../../../modules/effects/src/effects_feature_module.ts","../../../../modules/effects/src/effects_module.ts","../../../../modules/effects/src/act.ts","../../../../modules/effects/src/concat_latest_from.ts","../../../../modules/effects/src/provide_effects.ts","../../../../modules/effects/index.ts","../../../../modules/effects/ngrx-effects.ts"],"sourcesContent":["/**\n * Configures an effect created by `createEffect`.\n */\nexport interface EffectConfig {\n  /**\n   * Determines if the action emitted by the effect is dispatched to the store.\n   * If false, effect does not need to return type `Observable<Action>`.\n   */\n  dispatch?: boolean;\n  /**\n   * Determines if the effect will be resubscribed to if an error occurs in the main actions stream.\n   */\n  useEffectsErrorHandler?: boolean;\n}\n\nexport const DEFAULT_EFFECT_CONFIG: Readonly<Required<EffectConfig>> = {\n  dispatch: true,\n  useEffectsErrorHandler: true,\n};\n\nexport const CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n\nexport interface CreateEffectMetadata {\n  [CREATE_EFFECT_METADATA_KEY]: EffectConfig;\n}\n\nexport type EffectPropertyKey<T extends Object> = Exclude<\n  keyof T,\n  keyof Object\n>;\n\nexport interface EffectMetadata<T extends Object>\n  extends Required<EffectConfig> {\n  propertyName: EffectPropertyKey<T>;\n}\n\nexport type EffectsMetadata<T extends Object> = {\n  [Key in EffectPropertyKey<T>]?: EffectConfig;\n};\n","import { Observable } from 'rxjs';\nimport { Action, ActionCreator } from '@ngrx/store';\nimport {\n  EffectMetadata,\n  EffectConfig,\n  DEFAULT_EFFECT_CONFIG,\n  CreateEffectMetadata,\n  CREATE_EFFECT_METADATA_KEY,\n} from './models';\n\ntype DispatchType<T> = T extends { dispatch: infer U } ? U : true;\ntype ObservableType<T, OriginalType> = T extends false ? OriginalType : Action;\ntype EffectResult<OT> = Observable<OT> | ((...args: any[]) => Observable<OT>);\ntype ConditionallyDisallowActionCreator<DT, Result> = DT extends false\n  ? unknown // If DT (DispatchType is false, then we don't enforce any return types)\n  : Result extends EffectResult<infer OT>\n  ? OT extends ActionCreator\n    ? 'ActionCreator cannot be dispatched. Did you forget to call the action creator function?'\n    : unknown\n  : unknown;\n\n/**\n * @description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * @param source A function which returns an `Observable`.\n * @param config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true.\n * @returns If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n * @usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n */\nexport function createEffect<\n  C extends EffectConfig,\n  DT extends DispatchType<C>,\n  OT extends ObservableType<DT, OT>,\n  R extends EffectResult<OT>\n>(\n  source: () => R & ConditionallyDisallowActionCreator<DT, R>,\n  config?: Partial<C>\n): R & CreateEffectMetadata {\n  const effect = source();\n  const value: EffectConfig = {\n    ...DEFAULT_EFFECT_CONFIG,\n    ...config, // Overrides any defaults if values are provided\n  };\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value,\n  });\n  return effect as typeof effect & CreateEffectMetadata;\n}\n\nexport function getCreateEffectMetadata<\n  T extends { [props in keyof T]: Object }\n>(instance: T): EffectMetadata<T>[] {\n  const propertyNames = Object.getOwnPropertyNames(instance) as Array<keyof T>;\n\n  const metadata: EffectMetadata<T>[] = propertyNames\n    .filter((propertyName) => {\n      if (\n        instance[propertyName] &&\n        instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)\n      ) {\n        // If the property type has overridden `hasOwnProperty` we need to ensure\n        // that the metadata is valid (containing a `dispatch` property)\n        // https://github.com/ngrx/platform/issues/2975\n        const property = instance[propertyName] as any;\n        return property[CREATE_EFFECT_METADATA_KEY].hasOwnProperty('dispatch');\n      }\n      return false;\n    })\n    .map((propertyName) => {\n      const metaData = (instance[propertyName] as any)[\n        CREATE_EFFECT_METADATA_KEY\n      ];\n      return {\n        propertyName,\n        ...metaData,\n      };\n    });\n\n  return metadata;\n}\n","export function getSourceForInstance<T>(instance: T): T {\n  return Object.getPrototypeOf(instance);\n}\n\n// TODO: replace with RxJS interfaces when possible\n// needs dependency on RxJS >=7\nexport interface NextNotification<T> {\n  kind: 'N';\n  value: T;\n}\n\nexport interface ErrorNotification {\n  kind: 'E';\n  error: any;\n}\n\nexport interface CompleteNotification {\n  kind: 'C';\n}\n\nexport type ObservableNotification<T> =\n  | NextNotification<T>\n  | ErrorNotification\n  | CompleteNotification;\n","import { compose } from '@ngrx/store';\n\nimport {\n  DEFAULT_EFFECT_CONFIG,\n  EffectConfig,\n  EffectMetadata,\n  EffectPropertyKey,\n} from './models';\nimport { getSourceForInstance } from './utils';\n\nconst METADATA_KEY = '__@ngrx/effects__';\n\n/**\n * @deprecated The Effect decorator (`@Effect`) is deprecated in favor for the `createEffect` method.\n * See the docs for more info {@link https://ngrx.io/guide/migration/v11#the-effect-decorator}\n */\nexport function Effect(config: EffectConfig = {}) {\n  return function <T extends Object, K extends EffectPropertyKey<T>>(\n    target: T,\n    propertyName: K\n  ) {\n    const metadata: EffectMetadata<T> = {\n      ...DEFAULT_EFFECT_CONFIG,\n      ...config, // Overrides any defaults if values are provided\n      propertyName,\n    };\n    addEffectMetadataEntry<T>(target, metadata);\n  };\n}\n\nexport function getEffectDecoratorMetadata<T extends Object>(\n  instance: T\n): EffectMetadata<T>[] {\n  const effectsDecorators: EffectMetadata<T>[] = compose(\n    getEffectMetadataEntries,\n    getSourceForInstance\n  )(instance);\n\n  return effectsDecorators;\n}\n\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n */\nfunction hasMetadataEntries<T extends Object>(\n  sourceProto: T\n): sourceProto is typeof sourceProto & {\n  constructor: typeof sourceProto.constructor & {\n    [METADATA_KEY]: EffectMetadata<T>[];\n  };\n} {\n  return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n\n/** Add Effect Metadata to the Effect Class constructor under specific key */\nfunction addEffectMetadataEntry<T extends object>(\n  sourceProto: T,\n  metadata: EffectMetadata<T>\n) {\n  if (hasMetadataEntries(sourceProto)) {\n    sourceProto.constructor[METADATA_KEY].push(metadata);\n  } else {\n    Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n      value: [metadata],\n    });\n  }\n}\n\nfunction getEffectMetadataEntries<T extends object>(\n  sourceProto: T\n): EffectMetadata<T>[] {\n  return hasMetadataEntries(sourceProto)\n    ? sourceProto.constructor[METADATA_KEY]\n    : [];\n}\n","import { EffectMetadata, EffectsMetadata } from './models';\nimport { getCreateEffectMetadata } from './effect_creator';\nimport { getEffectDecoratorMetadata } from './effect_decorator';\n\nexport function getEffectsMetadata<T extends Object>(\n  instance: T\n): EffectsMetadata<T> {\n  return getSourceMetadata(instance).reduce(\n    (\n      acc: EffectsMetadata<T>,\n      { propertyName, dispatch, useEffectsErrorHandler }\n    ) => {\n      acc[propertyName] = { dispatch, useEffectsErrorHandler };\n      return acc;\n    },\n    {}\n  );\n}\n\nexport function getSourceMetadata<T extends Object>(\n  instance: T\n): EffectMetadata<T>[] {\n  const effects: Array<(instance: Object) => EffectMetadata<T>[]> = [\n    getEffectDecoratorMetadata,\n    getCreateEffectMetadata,\n  ];\n\n  return effects.reduce<EffectMetadata<T>[]>(\n    (sources, source) => sources.concat(source(instance)),\n    []\n  );\n}\n","import { Action } from '@ngrx/store';\nimport { merge, Observable } from 'rxjs';\nimport { ignoreElements, map, materialize } from 'rxjs/operators';\n\nimport { EffectNotification } from './effect_notification';\nimport { getSourceMetadata } from './effects_metadata';\nimport { EffectsErrorHandler } from './effects_error_handler';\nimport { getSourceForInstance } from './utils';\nimport { ErrorHandler } from '@angular/core';\n\nexport function mergeEffects(\n  sourceInstance: any,\n  globalErrorHandler: ErrorHandler,\n  effectsErrorHandler: EffectsErrorHandler\n): Observable<EffectNotification> {\n  const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n\n  const observables$: Observable<any>[] = getSourceMetadata(sourceInstance).map(\n    ({\n      propertyName,\n      dispatch,\n      useEffectsErrorHandler,\n    }): Observable<EffectNotification> => {\n      const observable$: Observable<any> =\n        typeof sourceInstance[propertyName] === 'function'\n          ? sourceInstance[propertyName]()\n          : sourceInstance[propertyName];\n\n      const effectAction$ = useEffectsErrorHandler\n        ? effectsErrorHandler(observable$, globalErrorHandler)\n        : observable$;\n\n      if (dispatch === false) {\n        return effectAction$.pipe(ignoreElements());\n      }\n\n      const materialized$ = effectAction$.pipe(materialize<Action>());\n\n      return materialized$.pipe(\n        map(\n          (notification): EffectNotification => ({\n            effect: sourceInstance[propertyName],\n            notification,\n            propertyName,\n            sourceName,\n            sourceInstance,\n          })\n        )\n      );\n    }\n  );\n\n  return merge(...observables$);\n}\n","import { ErrorHandler } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nexport type EffectsErrorHandler = <T extends Action>(\n  observable$: Observable<T>,\n  errorHandler: ErrorHandler\n) => Observable<T>;\n\nconst MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\n\nexport function defaultEffectsErrorHandler<T extends Action>(\n  observable$: Observable<T>,\n  errorHandler: ErrorHandler,\n  retryAttemptLeft: number = MAX_NUMBER_OF_RETRY_ATTEMPTS\n): Observable<T> {\n  return observable$.pipe(\n    catchError((error) => {\n      if (errorHandler) errorHandler.handleError(error);\n      if (retryAttemptLeft <= 1) {\n        return observable$; // last attempt\n      }\n      // Return observable that produces this particular effect\n      return defaultEffectsErrorHandler(\n        observable$,\n        errorHandler,\n        retryAttemptLeft - 1\n      );\n    })\n  );\n}\n","import { Inject, Injectable } from '@angular/core';\nimport {\n  Action,\n  ActionCreator,\n  Creator,\n  ScannedActionsSubject,\n} from '@ngrx/store';\nimport { Observable, OperatorFunction, Operator } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\n@Injectable({ providedIn: 'root' })\nexport class Actions<V = Action> extends Observable<V> {\n  constructor(@Inject(ScannedActionsSubject) source?: Observable<V>) {\n    super();\n\n    if (source) {\n      this.source = source;\n    }\n  }\n\n  override lift<R>(operator: Operator<V, R>): Observable<R> {\n    const observable = new Actions<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n}\n\n// Module-private helper type\ntype ActionExtractor<\n  T extends string | AC,\n  AC extends ActionCreator<string, Creator>,\n  E\n> = T extends string ? E : ReturnType<Extract<T, AC>>;\n\nexport function ofType<\n  AC extends ActionCreator<string, Creator>[],\n  U extends Action = Action,\n  V = ReturnType<AC[number]>\n>(...allowedTypes: AC): OperatorFunction<U, V>;\n\nexport function ofType<\n  E extends Extract<U, { type: T1 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  U extends Action = Action,\n  V = T1 extends string ? E : ReturnType<Extract<T1, AC>>\n>(t1: T1): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2, AC, E>\n>(t1: T1, t2: T2): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3, AC, E>\n>(t1: T1, t2: T2, t3: T3): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 | T4 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  T4 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3 | T4, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 | T4 | T5 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  T4 extends string | AC,\n  T5 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3 | T4 | T5, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): OperatorFunction<U, V>;\n/**\n * Fallback for more than 5 arguments.\n * There is no inference, so the return type is the same as the input -\n * Observable<Action>.\n *\n * We provide a type parameter, even though TS will not infer it from the\n * arguments, to preserve backwards compatibility with old versions of ngrx.\n */\nexport function ofType<V extends Action>(\n  ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, V>;\n/**\n * `ofType` filters an Observable of `Actions` into an Observable of the actions\n * whose type strings are passed to it.\n *\n * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and\n * the type of the `Addition` action is `add`, then\n * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.\n *\n * Properly typing this function is hard and requires some advanced TS tricks\n * below.\n *\n * Type narrowing automatically works, as long as your `actions` object\n * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.\n *\n * For backwards compatibility, when one passes a single type argument\n * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`\n * completely overrides any possible inference from 'something'.\n *\n * Unfortunately, for unknown 'actions: Actions' these types will produce\n * 'Observable<never>'. In such cases one has to manually set the generic type\n * like `actions.ofType<AdditionAction>('add')`.\n *\n * @usageNotes\n *\n * Filter the Actions stream on the \"customers page loaded\" action\n *\n * ```ts\n * import { ofType } from '@ngrx/effects';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  ofType(fromCustomers.pageLoaded)\n * )\n * ```\n */\nexport function ofType(\n  ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, Action> {\n  return filter((action: Action) =>\n    allowedTypes.some((typeOrActionCreator) => {\n      if (typeof typeOrActionCreator === 'string') {\n        // Comparing the string to type\n        return typeOrActionCreator === action.type;\n      }\n\n      // We are filtering by ActionCreator\n      return typeOrActionCreator.type === action.type;\n    })\n  );\n}\n","import { InjectionToken, Type } from '@angular/core';\nimport {\n  defaultEffectsErrorHandler,\n  EffectsErrorHandler,\n} from './effects_error_handler';\n\nexport const _ROOT_EFFECTS_GUARD = new InjectionToken<void>(\n  '@ngrx/effects Internal Root Guard'\n);\nexport const USER_PROVIDED_EFFECTS = new InjectionToken<Type<any>[][]>(\n  '@ngrx/effects User Provided Effects'\n);\nexport const _ROOT_EFFECTS = new InjectionToken<Type<any>[]>(\n  '@ngrx/effects Internal Root Effects'\n);\nexport const ROOT_EFFECTS = new InjectionToken<Type<any>[]>(\n  '@ngrx/effects Root Effects'\n);\nexport const _FEATURE_EFFECTS = new InjectionToken<Type<any>[]>(\n  '@ngrx/effects Internal Feature Effects'\n);\nexport const FEATURE_EFFECTS = new InjectionToken<any[][]>(\n  '@ngrx/effects Feature Effects'\n);\nexport const EFFECTS_ERROR_HANDLER = new InjectionToken<EffectsErrorHandler>(\n  '@ngrx/effects Effects Error Handler',\n  { providedIn: 'root', factory: () => defaultEffectsErrorHandler }\n);\n","import { createAction } from '@ngrx/store';\n\nexport const ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nexport const rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\n","import { ErrorHandler } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { ObservableNotification } from './utils';\n\nexport interface EffectNotification {\n  effect: Observable<any> | (() => Observable<any>);\n  propertyName: PropertyKey;\n  sourceName: string;\n  sourceInstance: any;\n  notification: ObservableNotification<Action | null | undefined>;\n}\n\nexport function reportInvalidActions(\n  output: EffectNotification,\n  reporter: ErrorHandler\n) {\n  if (output.notification.kind === 'N') {\n    const action = output.notification.value;\n    const isInvalidAction = !isAction(action);\n\n    if (isInvalidAction) {\n      reporter.handleError(\n        new Error(\n          `Effect ${getEffectName(\n            output\n          )} dispatched an invalid action: ${stringify(action)}`\n        )\n      );\n    }\n  }\n}\n\nfunction isAction(action: any): action is Action {\n  return (\n    typeof action !== 'function' &&\n    action &&\n    action.type &&\n    typeof action.type === 'string'\n  );\n}\n\nfunction getEffectName({\n  propertyName,\n  sourceInstance,\n  sourceName,\n}: EffectNotification) {\n  const isMethod = typeof sourceInstance[propertyName] === 'function';\n\n  return `\"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}\"`;\n}\n\nfunction stringify(action: Action | null | undefined) {\n  try {\n    return JSON.stringify(action);\n  } catch {\n    return action;\n  }\n}\n","import { Observable } from 'rxjs';\nimport { EffectNotification } from '.';\nimport { Action } from '@ngrx/store';\n\n/**\n * @description\n * Interface to set an identifier for effect instances.\n *\n * By default, each Effects class is registered\n * once regardless of how many times the Effect class\n * is loaded. By implementing this interface, you define\n * a unique identifier to register an Effects class instance\n * multiple times.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithIdentifier implements OnIdentifyEffects {\n *  constructor(private effectIdentifier: string) {}\n *\n *  ngrxOnIdentifyEffects() {\n *    return this.effectIdentifier;\n *  }\n *\n * ```\n */\nexport declare interface OnIdentifyEffects {\n  /**\n   * @description\n   * String identifier to differentiate effect instances.\n   */\n  ngrxOnIdentifyEffects(): string;\n}\n\nexport const onIdentifyEffectsKey: keyof OnIdentifyEffects =\n  'ngrxOnIdentifyEffects';\n\nexport function isOnIdentifyEffects(\n  instance: any\n): instance is OnIdentifyEffects {\n  return isFunction(instance, onIdentifyEffectsKey);\n}\n\n/**\n * @description\n * Interface to control the lifecycle of effects.\n *\n * By default, effects are merged and subscribed to the store. Implement the OnRunEffects interface to control the lifecycle of the resolved effects.\n *\n * @usageNotes\n *\n * ### Implement the OnRunEffects interface on an Effects class\n *\n * ```ts\n * export class UserEffects implements OnRunEffects {\n *   constructor(private actions$: Actions) {}\n *\n *   ngrxOnRunEffects(resolvedEffects$: Observable<EffectNotification>) {\n *     return this.actions$.pipe(\n *       ofType('LOGGED_IN'),\n *       exhaustMap(() =>\n *         resolvedEffects$.pipe(\n *           takeUntil(this.actions$.pipe(ofType('LOGGED_OUT')))\n *         )\n *       )\n *     );\n *   }\n * }\n * ```\n */\nexport declare interface OnRunEffects {\n  /**\n   * @description\n   * Method to control the lifecycle of effects.\n   */\n  ngrxOnRunEffects(\n    resolvedEffects$: Observable<EffectNotification>\n  ): Observable<EffectNotification>;\n}\n\nexport const onRunEffectsKey: keyof OnRunEffects = 'ngrxOnRunEffects';\n\nexport function isOnRunEffects(instance: any): instance is OnRunEffects {\n  return isFunction(instance, onRunEffectsKey);\n}\n\n/**\n * @description\n * Interface to dispatch an action after effect registration.\n *\n * Implement this interface to dispatch a custom action after\n * the effect has been added. You can listen to this action\n * in the rest of the application to execute something after\n * the effect is registered.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithInitAction implements OnInitEffects {\n *  ngrxOnInitEffects() {\n *    return { type: '[EffectWithInitAction] Init' };\n *  }\n * ```\n */\nexport declare interface OnInitEffects {\n  /**\n   * @description\n   * Action to be dispatched after the effect is registered.\n   */\n  ngrxOnInitEffects(): Action;\n}\n\nexport const onInitEffects: keyof OnInitEffects = 'ngrxOnInitEffects';\n\nexport function isOnInitEffects(instance: any): instance is OnInitEffects {\n  return isFunction(instance, onInitEffects);\n}\n\nfunction isFunction(instance: any, functionName: string) {\n  return (\n    instance &&\n    functionName in instance &&\n    typeof instance[functionName] === 'function'\n  );\n}\n","import { ErrorHandler, Inject, Injectable } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Observable, Subject, merge } from 'rxjs';\nimport {\n  dematerialize,\n  exhaustMap,\n  filter,\n  groupBy,\n  map,\n  mergeMap,\n  take,\n} from 'rxjs/operators';\n\nimport {\n  reportInvalidActions,\n  EffectNotification,\n} from './effect_notification';\nimport { EffectsErrorHandler } from './effects_error_handler';\nimport { mergeEffects } from './effects_resolver';\nimport {\n  onIdentifyEffectsKey,\n  onRunEffectsKey,\n  OnRunEffects,\n  onInitEffects,\n  isOnIdentifyEffects,\n  isOnRunEffects,\n  isOnInitEffects,\n} from './lifecycle_hooks';\nimport { EFFECTS_ERROR_HANDLER } from './tokens';\nimport { getSourceForInstance, ObservableNotification } from './utils';\n\n@Injectable({ providedIn: 'root' })\nexport class EffectSources extends Subject<any> {\n  constructor(\n    private errorHandler: ErrorHandler,\n    @Inject(EFFECTS_ERROR_HANDLER)\n    private effectsErrorHandler: EffectsErrorHandler\n  ) {\n    super();\n  }\n\n  addEffects(effectSourceInstance: any): void {\n    this.next(effectSourceInstance);\n  }\n\n  /**\n   * @internal\n   */\n  toActions(): Observable<Action> {\n    return this.pipe(\n      groupBy(getSourceForInstance),\n      mergeMap((source$) => {\n        return source$.pipe(groupBy(effectsInstance));\n      }),\n      mergeMap((source$) => {\n        const effect$ = source$.pipe(\n          exhaustMap((sourceInstance) => {\n            return resolveEffectSource(\n              this.errorHandler,\n              this.effectsErrorHandler\n            )(sourceInstance);\n          }),\n          map((output) => {\n            reportInvalidActions(output, this.errorHandler);\n            return output.notification;\n          }),\n          filter(\n            (notification): notification is ObservableNotification<Action> =>\n              notification.kind === 'N' && notification.value != null\n          ),\n          dematerialize()\n        );\n\n        // start the stream with an INIT action\n        // do this only for the first Effect instance\n        const init$ = source$.pipe(\n          take(1),\n          filter(isOnInitEffects),\n          map((instance) => instance.ngrxOnInitEffects())\n        );\n\n        return merge(effect$, init$);\n      })\n    );\n  }\n}\n\nfunction effectsInstance(sourceInstance: any) {\n  if (isOnIdentifyEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnIdentifyEffects();\n  }\n\n  return '';\n}\n\nfunction resolveEffectSource(\n  errorHandler: ErrorHandler,\n  effectsErrorHandler: EffectsErrorHandler\n): (sourceInstance: any) => Observable<EffectNotification> {\n  return (sourceInstance) => {\n    const mergedEffects$ = mergeEffects(\n      sourceInstance,\n      errorHandler,\n      effectsErrorHandler\n    );\n\n    if (isOnRunEffects(sourceInstance)) {\n      return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n\n    return mergedEffects$;\n  };\n}\n","import { Injectable, OnDestroy } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { Subscription } from 'rxjs';\n\nimport { EffectSources } from './effect_sources';\n\n@Injectable({ providedIn: 'root' })\nexport class EffectsRunner implements OnDestroy {\n  private effectsSubscription: Subscription | null = null;\n\n  get isStarted(): boolean {\n    return !!this.effectsSubscription;\n  }\n\n  constructor(\n    private effectSources: EffectSources,\n    private store: Store<any>\n  ) {}\n\n  start() {\n    if (!this.effectsSubscription) {\n      this.effectsSubscription = this.effectSources\n        .toActions()\n        .subscribe(this.store);\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.effectsSubscription) {\n      this.effectsSubscription.unsubscribe();\n      this.effectsSubscription = null;\n    }\n  }\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport { Store, StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { EffectsRunner } from './effects_runner';\nimport { EffectSources } from './effect_sources';\nimport { ROOT_EFFECTS, _ROOT_EFFECTS_GUARD } from './tokens';\nimport { ROOT_EFFECTS_INIT } from './effects_actions';\n\n@NgModule({})\nexport class EffectsRootModule {\n  constructor(\n    private sources: EffectSources,\n    runner: EffectsRunner,\n    store: Store<any>,\n    @Inject(ROOT_EFFECTS) rootEffects: any[],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule,\n    @Optional()\n    @Inject(_ROOT_EFFECTS_GUARD)\n    guard: any\n  ) {\n    runner.start();\n\n    rootEffects.forEach((effectSourceInstance) =>\n      sources.addEffects(effectSourceInstance)\n    );\n\n    store.dispatch({ type: ROOT_EFFECTS_INIT });\n  }\n\n  addEffects(effectSourceInstance: any) {\n    this.sources.addEffects(effectSourceInstance);\n  }\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport { StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { EffectsRootModule } from './effects_root_module';\nimport { FEATURE_EFFECTS } from './tokens';\n\n@NgModule({})\nexport class EffectsFeatureModule {\n  constructor(\n    root: EffectsRootModule,\n    @Inject(FEATURE_EFFECTS) effectSourceGroups: any[][],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule\n  ) {\n    effectSourceGroups.forEach((group) =>\n      group.forEach((effectSourceInstance) =>\n        root.addEffects(effectSourceInstance)\n      )\n    );\n  }\n}\n","import {\n  Injector,\n  ModuleWithProviders,\n  NgModule,\n  Optional,\n  Self,\n  SkipSelf,\n  Type,\n} from '@angular/core';\nimport { EffectsFeatureModule } from './effects_feature_module';\nimport { EffectsRootModule } from './effects_root_module';\nimport { EffectsRunner } from './effects_runner';\nimport {\n  _FEATURE_EFFECTS,\n  _ROOT_EFFECTS,\n  _ROOT_EFFECTS_GUARD,\n  FEATURE_EFFECTS,\n  ROOT_EFFECTS,\n  USER_PROVIDED_EFFECTS,\n} from './tokens';\n\n@NgModule({})\nexport class EffectsModule {\n  static forFeature(\n    featureEffects: Type<any>[] = []\n  ): ModuleWithProviders<EffectsFeatureModule> {\n    return {\n      ngModule: EffectsFeatureModule,\n      providers: [\n        featureEffects,\n        {\n          provide: _FEATURE_EFFECTS,\n          multi: true,\n          useValue: featureEffects,\n        },\n        {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: [],\n        },\n        {\n          provide: FEATURE_EFFECTS,\n          multi: true,\n          useFactory: createEffects,\n          deps: [Injector, _FEATURE_EFFECTS, USER_PROVIDED_EFFECTS],\n        },\n      ],\n    };\n  }\n\n  static forRoot(\n    rootEffects: Type<any>[] = []\n  ): ModuleWithProviders<EffectsRootModule> {\n    return {\n      ngModule: EffectsRootModule,\n      providers: [\n        rootEffects,\n        {\n          provide: _ROOT_EFFECTS,\n          useValue: [rootEffects],\n        },\n        {\n          provide: _ROOT_EFFECTS_GUARD,\n          useFactory: _provideForRootGuard,\n          deps: [\n            [EffectsRunner, new Optional(), new SkipSelf()],\n            [_ROOT_EFFECTS, new Self()],\n          ],\n        },\n        {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: [],\n        },\n        {\n          provide: ROOT_EFFECTS,\n          useFactory: createEffects,\n          deps: [Injector, _ROOT_EFFECTS, USER_PROVIDED_EFFECTS],\n        },\n      ],\n    };\n  }\n}\n\nexport function createEffects(\n  injector: Injector,\n  effectGroups: Type<any>[][],\n  userProvidedEffectGroups: Type<any>[][]\n): any[] {\n  const mergedEffects: Type<any>[] = [];\n\n  for (const effectGroup of effectGroups) {\n    mergedEffects.push(...effectGroup);\n  }\n\n  for (const userProvidedEffectGroup of userProvidedEffectGroups) {\n    mergedEffects.push(...userProvidedEffectGroup);\n  }\n\n  return createEffectInstances(injector, mergedEffects);\n}\n\nexport function createEffectInstances(\n  injector: Injector,\n  effects: Type<any>[]\n): any[] {\n  return effects.map((effect) => injector.get(effect));\n}\n\nexport function _provideForRootGuard(\n  runner: EffectsRunner,\n  rootEffects: any[][]\n): any {\n  // check whether any effects are actually passed\n  const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);\n  if (hasEffects && runner) {\n    throw new TypeError(\n      `EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`\n    );\n  }\n  return 'guarded';\n}\n","import { Action } from '@ngrx/store';\nimport { defer, merge, Observable, OperatorFunction, Subject } from 'rxjs';\nimport {\n  concatMap,\n  dematerialize,\n  filter,\n  finalize,\n  map,\n  materialize,\n} from 'rxjs/operators';\nimport { ObservableNotification } from './utils';\n\n/** Represents config with named parameters for act */\nexport interface ActConfig<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action,\n  UnsubscribeAction extends Action\n> {\n  // Project function that produces the output actions in success cases\n  project: (input: Input, index: number) => Observable<OutputAction>;\n  // Error handle function for project\n  // error that happened during project execution\n  // input value that project errored with\n  error: (error: any, input: Input) => ErrorAction;\n  // Optional complete action provider\n  // count is the number of actions project emitted before completion\n  // input value that project completed with\n  complete?: (count: number, input: Input) => CompleteAction;\n  // Optional flattening operator\n  operator?: <Input, OutputAction>(\n    project: (input: Input, index: number) => Observable<OutputAction>\n  ) => OperatorFunction<Input, OutputAction>;\n  // Optional unsubscribe action provider\n  // count is the number of actions project emitted before unsubscribing\n  // input value that was unsubscribed from\n  unsubscribe?: (count: number, input: Input) => UnsubscribeAction;\n}\n\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action\n>(\n  project: (input: Input, index: number) => Observable<OutputAction>,\n  error: (error: any, input: Input) => ErrorAction\n): (source: Observable<Input>) => Observable<OutputAction | ErrorAction>;\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  config: ActConfig<\n    Input,\n    OutputAction,\n    ErrorAction,\n    CompleteAction,\n    UnsubscribeAction\n  >\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n>;\n/**\n * Wraps project fn with error handling making it safe to use in Effects.\n * Takes either a config with named properties that represent different possible\n * callbacks or project/error callbacks that are required.\n */\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  /** Allow to take either config object or project/error functions */\n  configOrProject:\n    | ActConfig<\n        Input,\n        OutputAction,\n        ErrorAction,\n        CompleteAction,\n        UnsubscribeAction\n      >\n    | ((input: Input, index: number) => Observable<OutputAction>),\n  errorFn?: (error: any, input: Input) => ErrorAction\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n> {\n  const { project, error, complete, operator, unsubscribe } =\n    typeof configOrProject === 'function'\n      ? {\n          project: configOrProject,\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          error: errorFn!,\n          operator: concatMap,\n          complete: undefined,\n          unsubscribe: undefined,\n        }\n      : { ...configOrProject, operator: configOrProject.operator || concatMap };\n\n  type ResultAction =\n    | OutputAction\n    | ErrorAction\n    | CompleteAction\n    | UnsubscribeAction;\n  return (source) =>\n    defer((): Observable<ResultAction> => {\n      const subject = new Subject<UnsubscribeAction>();\n      return merge(\n        source.pipe(\n          operator((input, index) =>\n            defer(() => {\n              let completed = false;\n              let errored = false;\n              let projectedCount = 0;\n              return project(input, index).pipe(\n                materialize(),\n                map(\n                  (\n                    notification\n                  ):\n                    | ObservableNotification<\n                        ErrorAction | CompleteAction | OutputAction\n                      >\n                    | undefined => {\n                    switch (notification.kind) {\n                      case 'E':\n                        errored = true;\n                        return {\n                          kind: 'N',\n                          value: error(notification.error, input),\n                        };\n                      case 'C':\n                        completed = true;\n                        return complete\n                          ? {\n                              kind: 'N',\n                              value: complete(projectedCount, input),\n                            }\n                          : undefined;\n                      default:\n                        ++projectedCount;\n                        return notification as ObservableNotification<OutputAction>;\n                    }\n                  }\n                ),\n                filter((n): n is NonNullable<typeof n> => n != null),\n                dematerialize(),\n                finalize(() => {\n                  if (!completed && !errored && unsubscribe) {\n                    subject.next(unsubscribe(projectedCount, input));\n                  }\n                })\n              );\n            })\n          )\n        ),\n        subject\n      );\n    });\n}\n","import { Observable, ObservedValueOf, of, OperatorFunction, pipe } from 'rxjs';\nimport { concatMap, withLatestFrom } from 'rxjs/operators';\n\n// The array overload is needed first because we want to maintain the proper order in the resulting tuple\nexport function concatLatestFrom<T extends Observable<unknown>[], V>(\n  observablesFactory: (value: V) => [...T]\n): OperatorFunction<V, [V, ...{ [i in keyof T]: ObservedValueOf<T[i]> }]>;\nexport function concatLatestFrom<T extends Observable<unknown>, V>(\n  observableFactory: (value: V) => T\n): OperatorFunction<V, [V, ObservedValueOf<T>]>;\n/**\n * `concatLatestFrom` combines the source value\n * and the last available value from a lazily evaluated Observable\n * in a new array\n *\n * @usageNotes\n *\n * Select the active customer from the NgRx Store\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/effects';\n * import * as fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom(() => this.store.select(fromCustomers.selectActiveCustomer))\n * )\n * ```\n *\n * Select a customer from the NgRx Store by its id that is available on the action\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/effects';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom((action) => this.store.select(fromCustomers.selectCustomer(action.customerId)))\n * )\n * ```\n */\nexport function concatLatestFrom<\n  T extends Observable<unknown>[] | Observable<unknown>,\n  V,\n  R = [\n    V,\n    ...(T extends Observable<unknown>[]\n      ? { [i in keyof T]: ObservedValueOf<T[i]> }\n      : [ObservedValueOf<T>])\n  ]\n>(observablesFactory: (value: V) => T): OperatorFunction<V, R> {\n  return pipe(\n    concatMap((value) => {\n      const observables = observablesFactory(value);\n      const observablesAsArray = Array.isArray(observables)\n        ? observables\n        : [observables];\n      return of(value).pipe(\n        withLatestFrom(...observablesAsArray)\n      ) as unknown as Observable<R>;\n    })\n  );\n}\n","import {\n  ENVIRONMENT_INITIALIZER,\n  inject,\n  InjectFlags,\n  Type,\n} from '@angular/core';\nimport {\n  EnvironmentProviders,\n  FEATURE_STATE_PROVIDER,\n  ROOT_STORE_PROVIDER,\n  Store,\n} from '@ngrx/store';\nimport { EffectsRunner } from './effects_runner';\nimport { EffectSources } from './effect_sources';\nimport { rootEffectsInit as effectsInit } from './effects_actions';\n\n/**\n * Runs the provided effects.\n * Can be called at the root and feature levels.\n *\n * @usageNotes\n *\n * ### Providing effects at the root level\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [provideEffects([RouterEffects])],\n * });\n * ```\n *\n * ### Providing effects at the feature level\n *\n * ```ts\n * const booksRoutes: Route[] = [\n *   {\n *     path: '',\n *     providers: [provideEffects([BooksApiEffects])],\n *     children: [\n *       { path: '', component: BookListComponent },\n *       { path: ':id', component: BookDetailsComponent },\n *     ],\n *   },\n * ];\n * ```\n */\nexport function provideEffects(effects: Type<unknown>[]): EnvironmentProviders {\n  return {\n    Éµproviders: [\n      effects,\n      {\n        provide: ENVIRONMENT_INITIALIZER,\n        multi: true,\n        useValue: () => {\n          inject(ROOT_STORE_PROVIDER);\n          inject(FEATURE_STATE_PROVIDER, InjectFlags.Optional);\n\n          const effectsRunner = inject(EffectsRunner);\n          const effectSources = inject(EffectSources);\n          const shouldInitEffects = !effectsRunner.isStarted;\n\n          if (shouldInitEffects) {\n            effectsRunner.start();\n          }\n\n          for (const effectsClass of effects) {\n            const effectsInstance = inject(effectsClass);\n            effectSources.addEffects(effectsInstance);\n          }\n\n          if (shouldInitEffects) {\n            const store = inject(Store);\n            store.dispatch(effectsInit());\n          }\n        },\n      },\n    ],\n  };\n}\n","/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\nexport * from './public_api';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["i1.EffectSources","i2","i2.EffectsRunner","effectsInit"],"mappings":"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"}
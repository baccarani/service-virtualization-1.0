{"ast":null,"code":"import * as i3 from '@ngrx/store';\nimport { compose, ScannedActionsSubject, createAction, ROOT_STORE_PROVIDER, FEATURE_STATE_PROVIDER, Store } from '@ngrx/store';\nimport * as i1 from 'rxjs';\nimport { merge, Observable, Subject, defer, pipe, of } from 'rxjs';\nimport { ignoreElements, materialize, map, catchError, filter, groupBy, mergeMap, exhaustMap, dematerialize, take, concatMap, finalize, withLatestFrom } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, InjectionToken, NgModule, Optional, Injector, SkipSelf, Self, ENVIRONMENT_INITIALIZER, inject, InjectFlags } from '@angular/core';\nconst DEFAULT_EFFECT_CONFIG = {\n  dispatch: true,\n  useEffectsErrorHandler: true\n};\nconst CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n/**\n * @description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * @param source A function which returns an `Observable`.\n * @param config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true.\n * @returns If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n * @usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n */\n\nfunction createEffect(source, config) {\n  const effect = source();\n  const value = { ...DEFAULT_EFFECT_CONFIG,\n    ...config // Overrides any defaults if values are provided\n\n  };\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value\n  });\n  return effect;\n}\n\nfunction getCreateEffectMetadata(instance) {\n  const propertyNames = Object.getOwnPropertyNames(instance);\n  const metadata = propertyNames.filter(propertyName => {\n    if (instance[propertyName] && instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)) {\n      // If the property type has overridden `hasOwnProperty` we need to ensure\n      // that the metadata is valid (containing a `dispatch` property)\n      // https://github.com/ngrx/platform/issues/2975\n      const property = instance[propertyName];\n      return property[CREATE_EFFECT_METADATA_KEY].hasOwnProperty('dispatch');\n    }\n\n    return false;\n  }).map(propertyName => {\n    const metaData = instance[propertyName][CREATE_EFFECT_METADATA_KEY];\n    return {\n      propertyName,\n      ...metaData\n    };\n  });\n  return metadata;\n}\n\nfunction getSourceForInstance(instance) {\n  return Object.getPrototypeOf(instance);\n}\n\nconst METADATA_KEY = '__@ngrx/effects__';\n/**\n * @deprecated The Effect decorator (`@Effect`) is deprecated in favor for the `createEffect` method.\n * See the docs for more info {@link https://ngrx.io/guide/migration/v11#the-effect-decorator}\n */\n\nfunction Effect(config = {}) {\n  return function (target, propertyName) {\n    const metadata = { ...DEFAULT_EFFECT_CONFIG,\n      ...config,\n      propertyName\n    };\n    addEffectMetadataEntry(target, metadata);\n  };\n}\n\nfunction getEffectDecoratorMetadata(instance) {\n  const effectsDecorators = compose(getEffectMetadataEntries, getSourceForInstance)(instance);\n  return effectsDecorators;\n}\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n */\n\n\nfunction hasMetadataEntries(sourceProto) {\n  return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n/** Add Effect Metadata to the Effect Class constructor under specific key */\n\n\nfunction addEffectMetadataEntry(sourceProto, metadata) {\n  if (hasMetadataEntries(sourceProto)) {\n    sourceProto.constructor[METADATA_KEY].push(metadata);\n  } else {\n    Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n      value: [metadata]\n    });\n  }\n}\n\nfunction getEffectMetadataEntries(sourceProto) {\n  return hasMetadataEntries(sourceProto) ? sourceProto.constructor[METADATA_KEY] : [];\n}\n\nfunction getEffectsMetadata(instance) {\n  return getSourceMetadata(instance).reduce((acc, {\n    propertyName,\n    dispatch,\n    useEffectsErrorHandler\n  }) => {\n    acc[propertyName] = {\n      dispatch,\n      useEffectsErrorHandler\n    };\n    return acc;\n  }, {});\n}\n\nfunction getSourceMetadata(instance) {\n  const effects = [getEffectDecoratorMetadata, getCreateEffectMetadata];\n  return effects.reduce((sources, source) => sources.concat(source(instance)), []);\n}\n\nfunction mergeEffects(sourceInstance, globalErrorHandler, effectsErrorHandler) {\n  const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n  const observables$ = getSourceMetadata(sourceInstance).map(({\n    propertyName,\n    dispatch,\n    useEffectsErrorHandler\n  }) => {\n    const observable$ = typeof sourceInstance[propertyName] === 'function' ? sourceInstance[propertyName]() : sourceInstance[propertyName];\n    const effectAction$ = useEffectsErrorHandler ? effectsErrorHandler(observable$, globalErrorHandler) : observable$;\n\n    if (dispatch === false) {\n      return effectAction$.pipe(ignoreElements());\n    }\n\n    const materialized$ = effectAction$.pipe(materialize());\n    return materialized$.pipe(map(notification => ({\n      effect: sourceInstance[propertyName],\n      notification,\n      propertyName,\n      sourceName,\n      sourceInstance\n    })));\n  });\n  return merge(...observables$);\n}\n\nconst MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\n\nfunction defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft = MAX_NUMBER_OF_RETRY_ATTEMPTS) {\n  return observable$.pipe(catchError(error => {\n    if (errorHandler) errorHandler.handleError(error);\n\n    if (retryAttemptLeft <= 1) {\n      return observable$; // last attempt\n    } // Return observable that produces this particular effect\n\n\n    return defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft - 1);\n  }));\n}\n\nclass Actions extends Observable {\n  constructor(source) {\n    super();\n\n    if (source) {\n      this.source = source;\n    }\n  }\n\n  lift(operator) {\n    const observable = new Actions();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n}\n/** @nocollapse */\n\n\nActions.ɵfac = function Actions_Factory(t) {\n  return new (t || Actions)(i0.ɵɵinject(ScannedActionsSubject));\n};\n/** @nocollapse */\n\n\nActions.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: Actions,\n  factory: Actions.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Actions, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i1.Observable,\n      decorators: [{\n        type: Inject,\n        args: [ScannedActionsSubject]\n      }]\n    }];\n  }, null);\n})();\n/**\n * `ofType` filters an Observable of `Actions` into an Observable of the actions\n * whose type strings are passed to it.\n *\n * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and\n * the type of the `Addition` action is `add`, then\n * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.\n *\n * Properly typing this function is hard and requires some advanced TS tricks\n * below.\n *\n * Type narrowing automatically works, as long as your `actions` object\n * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.\n *\n * For backwards compatibility, when one passes a single type argument\n * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`\n * completely overrides any possible inference from 'something'.\n *\n * Unfortunately, for unknown 'actions: Actions' these types will produce\n * 'Observable<never>'. In such cases one has to manually set the generic type\n * like `actions.ofType<AdditionAction>('add')`.\n *\n * @usageNotes\n *\n * Filter the Actions stream on the \"customers page loaded\" action\n *\n * ```ts\n * import { ofType } from '@ngrx/effects';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  ofType(fromCustomers.pageLoaded)\n * )\n * ```\n */\n\n\nfunction ofType(...allowedTypes) {\n  return filter(action => allowedTypes.some(typeOrActionCreator => {\n    if (typeof typeOrActionCreator === 'string') {\n      // Comparing the string to type\n      return typeOrActionCreator === action.type;\n    } // We are filtering by ActionCreator\n\n\n    return typeOrActionCreator.type === action.type;\n  }));\n}\n\nconst _ROOT_EFFECTS_GUARD = new InjectionToken('@ngrx/effects Internal Root Guard');\n\nconst USER_PROVIDED_EFFECTS = new InjectionToken('@ngrx/effects User Provided Effects');\n\nconst _ROOT_EFFECTS = new InjectionToken('@ngrx/effects Internal Root Effects');\n\nconst ROOT_EFFECTS = new InjectionToken('@ngrx/effects Root Effects');\n\nconst _FEATURE_EFFECTS = new InjectionToken('@ngrx/effects Internal Feature Effects');\n\nconst FEATURE_EFFECTS = new InjectionToken('@ngrx/effects Feature Effects');\nconst EFFECTS_ERROR_HANDLER = new InjectionToken('@ngrx/effects Effects Error Handler', {\n  providedIn: 'root',\n  factory: () => defaultEffectsErrorHandler\n});\nconst ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nconst rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\n\nfunction reportInvalidActions(output, reporter) {\n  if (output.notification.kind === 'N') {\n    const action = output.notification.value;\n    const isInvalidAction = !isAction(action);\n\n    if (isInvalidAction) {\n      reporter.handleError(new Error(`Effect ${getEffectName(output)} dispatched an invalid action: ${stringify(action)}`));\n    }\n  }\n}\n\nfunction isAction(action) {\n  return typeof action !== 'function' && action && action.type && typeof action.type === 'string';\n}\n\nfunction getEffectName({\n  propertyName,\n  sourceInstance,\n  sourceName\n}) {\n  const isMethod = typeof sourceInstance[propertyName] === 'function';\n  return `\"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}\"`;\n}\n\nfunction stringify(action) {\n  try {\n    return JSON.stringify(action);\n  } catch {\n    return action;\n  }\n}\n\nconst onIdentifyEffectsKey = 'ngrxOnIdentifyEffects';\n\nfunction isOnIdentifyEffects(instance) {\n  return isFunction(instance, onIdentifyEffectsKey);\n}\n\nconst onRunEffectsKey = 'ngrxOnRunEffects';\n\nfunction isOnRunEffects(instance) {\n  return isFunction(instance, onRunEffectsKey);\n}\n\nconst onInitEffects = 'ngrxOnInitEffects';\n\nfunction isOnInitEffects(instance) {\n  return isFunction(instance, onInitEffects);\n}\n\nfunction isFunction(instance, functionName) {\n  return instance && functionName in instance && typeof instance[functionName] === 'function';\n}\n\nclass EffectSources extends Subject {\n  constructor(errorHandler, effectsErrorHandler) {\n    super();\n    this.errorHandler = errorHandler;\n    this.effectsErrorHandler = effectsErrorHandler;\n  }\n\n  addEffects(effectSourceInstance) {\n    this.next(effectSourceInstance);\n  }\n  /**\n   * @internal\n   */\n\n\n  toActions() {\n    return this.pipe(groupBy(getSourceForInstance), mergeMap(source$ => {\n      return source$.pipe(groupBy(effectsInstance));\n    }), mergeMap(source$ => {\n      const effect$ = source$.pipe(exhaustMap(sourceInstance => {\n        return resolveEffectSource(this.errorHandler, this.effectsErrorHandler)(sourceInstance);\n      }), map(output => {\n        reportInvalidActions(output, this.errorHandler);\n        return output.notification;\n      }), filter(notification => notification.kind === 'N' && notification.value != null), dematerialize()); // start the stream with an INIT action\n      // do this only for the first Effect instance\n\n      const init$ = source$.pipe(take(1), filter(isOnInitEffects), map(instance => instance.ngrxOnInitEffects()));\n      return merge(effect$, init$);\n    }));\n  }\n\n}\n/** @nocollapse */\n\n\nEffectSources.ɵfac = function EffectSources_Factory(t) {\n  return new (t || EffectSources)(i0.ɵɵinject(i0.ErrorHandler), i0.ɵɵinject(EFFECTS_ERROR_HANDLER));\n};\n/** @nocollapse */\n\n\nEffectSources.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: EffectSources,\n  factory: EffectSources.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(EffectSources, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.ErrorHandler\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [EFFECTS_ERROR_HANDLER]\n      }]\n    }];\n  }, null);\n})();\n\nfunction effectsInstance(sourceInstance) {\n  if (isOnIdentifyEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnIdentifyEffects();\n  }\n\n  return '';\n}\n\nfunction resolveEffectSource(errorHandler, effectsErrorHandler) {\n  return sourceInstance => {\n    const mergedEffects$ = mergeEffects(sourceInstance, errorHandler, effectsErrorHandler);\n\n    if (isOnRunEffects(sourceInstance)) {\n      return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n\n    return mergedEffects$;\n  };\n}\n\nclass EffectsRunner {\n  constructor(effectSources, store) {\n    this.effectSources = effectSources;\n    this.store = store;\n    this.effectsSubscription = null;\n  }\n\n  get isStarted() {\n    return !!this.effectsSubscription;\n  }\n\n  start() {\n    if (!this.effectsSubscription) {\n      this.effectsSubscription = this.effectSources.toActions().subscribe(this.store);\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.effectsSubscription) {\n      this.effectsSubscription.unsubscribe();\n      this.effectsSubscription = null;\n    }\n  }\n\n}\n/** @nocollapse */\n\n\nEffectsRunner.ɵfac = function EffectsRunner_Factory(t) {\n  return new (t || EffectsRunner)(i0.ɵɵinject(EffectSources), i0.ɵɵinject(i3.Store));\n};\n/** @nocollapse */\n\n\nEffectsRunner.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: EffectsRunner,\n  factory: EffectsRunner.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(EffectsRunner, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: EffectSources\n    }, {\n      type: i3.Store\n    }];\n  }, null);\n})();\n\nclass EffectsRootModule {\n  constructor(sources, runner, store, rootEffects, storeRootModule, storeFeatureModule, guard) {\n    this.sources = sources;\n    runner.start();\n    rootEffects.forEach(effectSourceInstance => sources.addEffects(effectSourceInstance));\n    store.dispatch({\n      type: ROOT_EFFECTS_INIT\n    });\n  }\n\n  addEffects(effectSourceInstance) {\n    this.sources.addEffects(effectSourceInstance);\n  }\n\n}\n/** @nocollapse */\n\n\nEffectsRootModule.ɵfac = function EffectsRootModule_Factory(t) {\n  return new (t || EffectsRootModule)(i0.ɵɵinject(EffectSources), i0.ɵɵinject(EffectsRunner), i0.ɵɵinject(i3.Store), i0.ɵɵinject(ROOT_EFFECTS), i0.ɵɵinject(i3.StoreRootModule, 8), i0.ɵɵinject(i3.StoreFeatureModule, 8), i0.ɵɵinject(_ROOT_EFFECTS_GUARD, 8));\n};\n/** @nocollapse */\n\n\nEffectsRootModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: EffectsRootModule\n});\n/** @nocollapse */\n\nEffectsRootModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(EffectsRootModule, [{\n    type: NgModule,\n    args: [{}]\n  }], function () {\n    return [{\n      type: EffectSources\n    }, {\n      type: EffectsRunner\n    }, {\n      type: i3.Store\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [ROOT_EFFECTS]\n      }]\n    }, {\n      type: i3.StoreRootModule,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: i3.StoreFeatureModule,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [_ROOT_EFFECTS_GUARD]\n      }]\n    }];\n  }, null);\n})();\n\nclass EffectsFeatureModule {\n  constructor(root, effectSourceGroups, storeRootModule, storeFeatureModule) {\n    effectSourceGroups.forEach(group => group.forEach(effectSourceInstance => root.addEffects(effectSourceInstance)));\n  }\n\n}\n/** @nocollapse */\n\n\nEffectsFeatureModule.ɵfac = function EffectsFeatureModule_Factory(t) {\n  return new (t || EffectsFeatureModule)(i0.ɵɵinject(EffectsRootModule), i0.ɵɵinject(FEATURE_EFFECTS), i0.ɵɵinject(i3.StoreRootModule, 8), i0.ɵɵinject(i3.StoreFeatureModule, 8));\n};\n/** @nocollapse */\n\n\nEffectsFeatureModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: EffectsFeatureModule\n});\n/** @nocollapse */\n\nEffectsFeatureModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(EffectsFeatureModule, [{\n    type: NgModule,\n    args: [{}]\n  }], function () {\n    return [{\n      type: EffectsRootModule\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [FEATURE_EFFECTS]\n      }]\n    }, {\n      type: i3.StoreRootModule,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: i3.StoreFeatureModule,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\nclass EffectsModule {\n  static forFeature(featureEffects = []) {\n    return {\n      ngModule: EffectsFeatureModule,\n      providers: [featureEffects, {\n        provide: _FEATURE_EFFECTS,\n        multi: true,\n        useValue: featureEffects\n      }, {\n        provide: USER_PROVIDED_EFFECTS,\n        multi: true,\n        useValue: []\n      }, {\n        provide: FEATURE_EFFECTS,\n        multi: true,\n        useFactory: createEffects,\n        deps: [Injector, _FEATURE_EFFECTS, USER_PROVIDED_EFFECTS]\n      }]\n    };\n  }\n\n  static forRoot(rootEffects = []) {\n    return {\n      ngModule: EffectsRootModule,\n      providers: [rootEffects, {\n        provide: _ROOT_EFFECTS,\n        useValue: [rootEffects]\n      }, {\n        provide: _ROOT_EFFECTS_GUARD,\n        useFactory: _provideForRootGuard,\n        deps: [[EffectsRunner, new Optional(), new SkipSelf()], [_ROOT_EFFECTS, new Self()]]\n      }, {\n        provide: USER_PROVIDED_EFFECTS,\n        multi: true,\n        useValue: []\n      }, {\n        provide: ROOT_EFFECTS,\n        useFactory: createEffects,\n        deps: [Injector, _ROOT_EFFECTS, USER_PROVIDED_EFFECTS]\n      }]\n    };\n  }\n\n}\n/** @nocollapse */\n\n\nEffectsModule.ɵfac = function EffectsModule_Factory(t) {\n  return new (t || EffectsModule)();\n};\n/** @nocollapse */\n\n\nEffectsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: EffectsModule\n});\n/** @nocollapse */\n\nEffectsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(EffectsModule, [{\n    type: NgModule,\n    args: [{}]\n  }], null, null);\n})();\n\nfunction createEffects(injector, effectGroups, userProvidedEffectGroups) {\n  const mergedEffects = [];\n\n  for (const effectGroup of effectGroups) {\n    mergedEffects.push(...effectGroup);\n  }\n\n  for (const userProvidedEffectGroup of userProvidedEffectGroups) {\n    mergedEffects.push(...userProvidedEffectGroup);\n  }\n\n  return createEffectInstances(injector, mergedEffects);\n}\n\nfunction createEffectInstances(injector, effects) {\n  return effects.map(effect => injector.get(effect));\n}\n\nfunction _provideForRootGuard(runner, rootEffects) {\n  // check whether any effects are actually passed\n  const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);\n\n  if (hasEffects && runner) {\n    throw new TypeError(`EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`);\n  }\n\n  return 'guarded';\n}\n/**\n * Wraps project fn with error handling making it safe to use in Effects.\n * Takes either a config with named properties that represent different possible\n * callbacks or project/error callbacks that are required.\n */\n\n\nfunction act(\n/** Allow to take either config object or project/error functions */\nconfigOrProject, errorFn) {\n  const {\n    project,\n    error,\n    complete,\n    operator,\n    unsubscribe\n  } = typeof configOrProject === 'function' ? {\n    project: configOrProject,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    error: errorFn,\n    operator: concatMap,\n    complete: undefined,\n    unsubscribe: undefined\n  } : { ...configOrProject,\n    operator: configOrProject.operator || concatMap\n  };\n  return source => defer(() => {\n    const subject = new Subject();\n    return merge(source.pipe(operator((input, index) => defer(() => {\n      let completed = false;\n      let errored = false;\n      let projectedCount = 0;\n      return project(input, index).pipe(materialize(), map(notification => {\n        switch (notification.kind) {\n          case 'E':\n            errored = true;\n            return {\n              kind: 'N',\n              value: error(notification.error, input)\n            };\n\n          case 'C':\n            completed = true;\n            return complete ? {\n              kind: 'N',\n              value: complete(projectedCount, input)\n            } : undefined;\n\n          default:\n            ++projectedCount;\n            return notification;\n        }\n      }), filter(n => n != null), dematerialize(), finalize(() => {\n        if (!completed && !errored && unsubscribe) {\n          subject.next(unsubscribe(projectedCount, input));\n        }\n      }));\n    }))), subject);\n  });\n}\n/**\n * `concatLatestFrom` combines the source value\n * and the last available value from a lazily evaluated Observable\n * in a new array\n *\n * @usageNotes\n *\n * Select the active customer from the NgRx Store\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/effects';\n * import * as fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom(() => this.store.select(fromCustomers.selectActiveCustomer))\n * )\n * ```\n *\n * Select a customer from the NgRx Store by its id that is available on the action\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/effects';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom((action) => this.store.select(fromCustomers.selectCustomer(action.customerId)))\n * )\n * ```\n */\n\n\nfunction concatLatestFrom(observablesFactory) {\n  return pipe(concatMap(value => {\n    const observables = observablesFactory(value);\n    const observablesAsArray = Array.isArray(observables) ? observables : [observables];\n    return of(value).pipe(withLatestFrom(...observablesAsArray));\n  }));\n}\n/**\n * Runs the provided effects.\n * Can be called at the root and feature levels.\n *\n * @usageNotes\n *\n * ### Providing effects at the root level\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [provideEffects([RouterEffects])],\n * });\n * ```\n *\n * ### Providing effects at the feature level\n *\n * ```ts\n * const booksRoutes: Route[] = [\n *   {\n *     path: '',\n *     providers: [provideEffects([BooksApiEffects])],\n *     children: [\n *       { path: '', component: BookListComponent },\n *       { path: ':id', component: BookDetailsComponent },\n *     ],\n *   },\n * ];\n * ```\n */\n\n\nfunction provideEffects(effects) {\n  return {\n    ɵproviders: [effects, {\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useValue: () => {\n        inject(ROOT_STORE_PROVIDER);\n        inject(FEATURE_STATE_PROVIDER, InjectFlags.Optional);\n        const effectsRunner = inject(EffectsRunner);\n        const effectSources = inject(EffectSources);\n        const shouldInitEffects = !effectsRunner.isStarted;\n\n        if (shouldInitEffects) {\n          effectsRunner.start();\n        }\n\n        for (const effectsClass of effects) {\n          const effectsInstance = inject(effectsClass);\n          effectSources.addEffects(effectsInstance);\n        }\n\n        if (shouldInitEffects) {\n          const store = inject(Store);\n          store.dispatch(rootEffectsInit());\n        }\n      }\n    }]\n  };\n}\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Actions, EFFECTS_ERROR_HANDLER, Effect, EffectSources, EffectsFeatureModule, EffectsModule, EffectsRootModule, EffectsRunner, ROOT_EFFECTS_INIT, USER_PROVIDED_EFFECTS, act, concatLatestFrom, createEffect, defaultEffectsErrorHandler, getEffectsMetadata, mergeEffects, ofType, provideEffects, rootEffectsInit };","map":{"version":3,"names":["i3","compose","ScannedActionsSubject","createAction","ROOT_STORE_PROVIDER","FEATURE_STATE_PROVIDER","Store","i1","merge","Observable","Subject","defer","pipe","of","ignoreElements","materialize","map","catchError","filter","groupBy","mergeMap","exhaustMap","dematerialize","take","concatMap","finalize","withLatestFrom","i0","Injectable","Inject","InjectionToken","NgModule","Optional","Injector","SkipSelf","Self","ENVIRONMENT_INITIALIZER","inject","InjectFlags","DEFAULT_EFFECT_CONFIG","dispatch","useEffectsErrorHandler","CREATE_EFFECT_METADATA_KEY","createEffect","source","config","effect","value","Object","defineProperty","getCreateEffectMetadata","instance","propertyNames","getOwnPropertyNames","metadata","propertyName","hasOwnProperty","property","metaData","getSourceForInstance","getPrototypeOf","METADATA_KEY","Effect","target","addEffectMetadataEntry","getEffectDecoratorMetadata","effectsDecorators","getEffectMetadataEntries","hasMetadataEntries","sourceProto","constructor","push","getEffectsMetadata","getSourceMetadata","reduce","acc","effects","sources","concat","mergeEffects","sourceInstance","globalErrorHandler","effectsErrorHandler","sourceName","name","observables$","observable$","effectAction$","materialized$","notification","MAX_NUMBER_OF_RETRY_ATTEMPTS","defaultEffectsErrorHandler","errorHandler","retryAttemptLeft","error","handleError","Actions","lift","operator","observable","ɵfac","ɵprov","type","args","providedIn","decorators","ofType","allowedTypes","action","some","typeOrActionCreator","_ROOT_EFFECTS_GUARD","USER_PROVIDED_EFFECTS","_ROOT_EFFECTS","ROOT_EFFECTS","_FEATURE_EFFECTS","FEATURE_EFFECTS","EFFECTS_ERROR_HANDLER","factory","ROOT_EFFECTS_INIT","rootEffectsInit","reportInvalidActions","output","reporter","kind","isInvalidAction","isAction","Error","getEffectName","stringify","isMethod","String","JSON","onIdentifyEffectsKey","isOnIdentifyEffects","isFunction","onRunEffectsKey","isOnRunEffects","onInitEffects","isOnInitEffects","functionName","EffectSources","addEffects","effectSourceInstance","next","toActions","source$","effectsInstance","effect$","resolveEffectSource","init$","ngrxOnInitEffects","ErrorHandler","undefined","ngrxOnIdentifyEffects","mergedEffects$","ngrxOnRunEffects","EffectsRunner","effectSources","store","effectsSubscription","isStarted","start","subscribe","ngOnDestroy","unsubscribe","EffectsRootModule","runner","rootEffects","storeRootModule","storeFeatureModule","guard","forEach","StoreRootModule","StoreFeatureModule","ɵmod","ɵinj","EffectsFeatureModule","root","effectSourceGroups","group","EffectsModule","forFeature","featureEffects","ngModule","providers","provide","multi","useValue","useFactory","createEffects","deps","forRoot","_provideForRootGuard","injector","effectGroups","userProvidedEffectGroups","mergedEffects","effectGroup","userProvidedEffectGroup","createEffectInstances","get","hasEffects","length","TypeError","act","configOrProject","errorFn","project","complete","subject","input","index","completed","errored","projectedCount","n","concatLatestFrom","observablesFactory","observables","observablesAsArray","Array","isArray","provideEffects","ɵproviders","effectsRunner","shouldInitEffects","effectsClass"],"sources":["/Users/BPHA/Documents/GitHub/mountebank-1.0/frontend/node_modules/@ngrx/effects/fesm2020/ngrx-effects.mjs"],"sourcesContent":["import * as i3 from '@ngrx/store';\nimport { compose, ScannedActionsSubject, createAction, ROOT_STORE_PROVIDER, FEATURE_STATE_PROVIDER, Store } from '@ngrx/store';\nimport * as i1 from 'rxjs';\nimport { merge, Observable, Subject, defer, pipe, of } from 'rxjs';\nimport { ignoreElements, materialize, map, catchError, filter, groupBy, mergeMap, exhaustMap, dematerialize, take, concatMap, finalize, withLatestFrom } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, InjectionToken, NgModule, Optional, Injector, SkipSelf, Self, ENVIRONMENT_INITIALIZER, inject, InjectFlags } from '@angular/core';\n\nconst DEFAULT_EFFECT_CONFIG = {\n    dispatch: true,\n    useEffectsErrorHandler: true,\n};\nconst CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n\n/**\n * @description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * @param source A function which returns an `Observable`.\n * @param config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true.\n * @returns If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n * @usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n */\nfunction createEffect(source, config) {\n    const effect = source();\n    const value = {\n        ...DEFAULT_EFFECT_CONFIG,\n        ...config, // Overrides any defaults if values are provided\n    };\n    Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n        value,\n    });\n    return effect;\n}\nfunction getCreateEffectMetadata(instance) {\n    const propertyNames = Object.getOwnPropertyNames(instance);\n    const metadata = propertyNames\n        .filter((propertyName) => {\n        if (instance[propertyName] &&\n            instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)) {\n            // If the property type has overridden `hasOwnProperty` we need to ensure\n            // that the metadata is valid (containing a `dispatch` property)\n            // https://github.com/ngrx/platform/issues/2975\n            const property = instance[propertyName];\n            return property[CREATE_EFFECT_METADATA_KEY].hasOwnProperty('dispatch');\n        }\n        return false;\n    })\n        .map((propertyName) => {\n        const metaData = instance[propertyName][CREATE_EFFECT_METADATA_KEY];\n        return {\n            propertyName,\n            ...metaData,\n        };\n    });\n    return metadata;\n}\n\nfunction getSourceForInstance(instance) {\n    return Object.getPrototypeOf(instance);\n}\n\nconst METADATA_KEY = '__@ngrx/effects__';\n/**\n * @deprecated The Effect decorator (`@Effect`) is deprecated in favor for the `createEffect` method.\n * See the docs for more info {@link https://ngrx.io/guide/migration/v11#the-effect-decorator}\n */\nfunction Effect(config = {}) {\n    return function (target, propertyName) {\n        const metadata = {\n            ...DEFAULT_EFFECT_CONFIG,\n            ...config,\n            propertyName,\n        };\n        addEffectMetadataEntry(target, metadata);\n    };\n}\nfunction getEffectDecoratorMetadata(instance) {\n    const effectsDecorators = compose(getEffectMetadataEntries, getSourceForInstance)(instance);\n    return effectsDecorators;\n}\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n */\nfunction hasMetadataEntries(sourceProto) {\n    return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n/** Add Effect Metadata to the Effect Class constructor under specific key */\nfunction addEffectMetadataEntry(sourceProto, metadata) {\n    if (hasMetadataEntries(sourceProto)) {\n        sourceProto.constructor[METADATA_KEY].push(metadata);\n    }\n    else {\n        Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n            value: [metadata],\n        });\n    }\n}\nfunction getEffectMetadataEntries(sourceProto) {\n    return hasMetadataEntries(sourceProto)\n        ? sourceProto.constructor[METADATA_KEY]\n        : [];\n}\n\nfunction getEffectsMetadata(instance) {\n    return getSourceMetadata(instance).reduce((acc, { propertyName, dispatch, useEffectsErrorHandler }) => {\n        acc[propertyName] = { dispatch, useEffectsErrorHandler };\n        return acc;\n    }, {});\n}\nfunction getSourceMetadata(instance) {\n    const effects = [\n        getEffectDecoratorMetadata,\n        getCreateEffectMetadata,\n    ];\n    return effects.reduce((sources, source) => sources.concat(source(instance)), []);\n}\n\nfunction mergeEffects(sourceInstance, globalErrorHandler, effectsErrorHandler) {\n    const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n    const observables$ = getSourceMetadata(sourceInstance).map(({ propertyName, dispatch, useEffectsErrorHandler, }) => {\n        const observable$ = typeof sourceInstance[propertyName] === 'function'\n            ? sourceInstance[propertyName]()\n            : sourceInstance[propertyName];\n        const effectAction$ = useEffectsErrorHandler\n            ? effectsErrorHandler(observable$, globalErrorHandler)\n            : observable$;\n        if (dispatch === false) {\n            return effectAction$.pipe(ignoreElements());\n        }\n        const materialized$ = effectAction$.pipe(materialize());\n        return materialized$.pipe(map((notification) => ({\n            effect: sourceInstance[propertyName],\n            notification,\n            propertyName,\n            sourceName,\n            sourceInstance,\n        })));\n    });\n    return merge(...observables$);\n}\n\nconst MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\nfunction defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft = MAX_NUMBER_OF_RETRY_ATTEMPTS) {\n    return observable$.pipe(catchError((error) => {\n        if (errorHandler)\n            errorHandler.handleError(error);\n        if (retryAttemptLeft <= 1) {\n            return observable$; // last attempt\n        }\n        // Return observable that produces this particular effect\n        return defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft - 1);\n    }));\n}\n\nclass Actions extends Observable {\n    constructor(source) {\n        super();\n        if (source) {\n            this.source = source;\n        }\n    }\n    lift(operator) {\n        const observable = new Actions();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    }\n}\n/** @nocollapse */ Actions.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: Actions, deps: [{ token: ScannedActionsSubject }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ Actions.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: Actions, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: Actions, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: i1.Observable, decorators: [{\n                    type: Inject,\n                    args: [ScannedActionsSubject]\n                }] }]; } });\n/**\n * `ofType` filters an Observable of `Actions` into an Observable of the actions\n * whose type strings are passed to it.\n *\n * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and\n * the type of the `Addition` action is `add`, then\n * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.\n *\n * Properly typing this function is hard and requires some advanced TS tricks\n * below.\n *\n * Type narrowing automatically works, as long as your `actions` object\n * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.\n *\n * For backwards compatibility, when one passes a single type argument\n * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`\n * completely overrides any possible inference from 'something'.\n *\n * Unfortunately, for unknown 'actions: Actions' these types will produce\n * 'Observable<never>'. In such cases one has to manually set the generic type\n * like `actions.ofType<AdditionAction>('add')`.\n *\n * @usageNotes\n *\n * Filter the Actions stream on the \"customers page loaded\" action\n *\n * ```ts\n * import { ofType } from '@ngrx/effects';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  ofType(fromCustomers.pageLoaded)\n * )\n * ```\n */\nfunction ofType(...allowedTypes) {\n    return filter((action) => allowedTypes.some((typeOrActionCreator) => {\n        if (typeof typeOrActionCreator === 'string') {\n            // Comparing the string to type\n            return typeOrActionCreator === action.type;\n        }\n        // We are filtering by ActionCreator\n        return typeOrActionCreator.type === action.type;\n    }));\n}\n\nconst _ROOT_EFFECTS_GUARD = new InjectionToken('@ngrx/effects Internal Root Guard');\nconst USER_PROVIDED_EFFECTS = new InjectionToken('@ngrx/effects User Provided Effects');\nconst _ROOT_EFFECTS = new InjectionToken('@ngrx/effects Internal Root Effects');\nconst ROOT_EFFECTS = new InjectionToken('@ngrx/effects Root Effects');\nconst _FEATURE_EFFECTS = new InjectionToken('@ngrx/effects Internal Feature Effects');\nconst FEATURE_EFFECTS = new InjectionToken('@ngrx/effects Feature Effects');\nconst EFFECTS_ERROR_HANDLER = new InjectionToken('@ngrx/effects Effects Error Handler', { providedIn: 'root', factory: () => defaultEffectsErrorHandler });\n\nconst ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nconst rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\n\nfunction reportInvalidActions(output, reporter) {\n    if (output.notification.kind === 'N') {\n        const action = output.notification.value;\n        const isInvalidAction = !isAction(action);\n        if (isInvalidAction) {\n            reporter.handleError(new Error(`Effect ${getEffectName(output)} dispatched an invalid action: ${stringify(action)}`));\n        }\n    }\n}\nfunction isAction(action) {\n    return (typeof action !== 'function' &&\n        action &&\n        action.type &&\n        typeof action.type === 'string');\n}\nfunction getEffectName({ propertyName, sourceInstance, sourceName, }) {\n    const isMethod = typeof sourceInstance[propertyName] === 'function';\n    return `\"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}\"`;\n}\nfunction stringify(action) {\n    try {\n        return JSON.stringify(action);\n    }\n    catch {\n        return action;\n    }\n}\n\nconst onIdentifyEffectsKey = 'ngrxOnIdentifyEffects';\nfunction isOnIdentifyEffects(instance) {\n    return isFunction(instance, onIdentifyEffectsKey);\n}\nconst onRunEffectsKey = 'ngrxOnRunEffects';\nfunction isOnRunEffects(instance) {\n    return isFunction(instance, onRunEffectsKey);\n}\nconst onInitEffects = 'ngrxOnInitEffects';\nfunction isOnInitEffects(instance) {\n    return isFunction(instance, onInitEffects);\n}\nfunction isFunction(instance, functionName) {\n    return (instance &&\n        functionName in instance &&\n        typeof instance[functionName] === 'function');\n}\n\nclass EffectSources extends Subject {\n    constructor(errorHandler, effectsErrorHandler) {\n        super();\n        this.errorHandler = errorHandler;\n        this.effectsErrorHandler = effectsErrorHandler;\n    }\n    addEffects(effectSourceInstance) {\n        this.next(effectSourceInstance);\n    }\n    /**\n     * @internal\n     */\n    toActions() {\n        return this.pipe(groupBy(getSourceForInstance), mergeMap((source$) => {\n            return source$.pipe(groupBy(effectsInstance));\n        }), mergeMap((source$) => {\n            const effect$ = source$.pipe(exhaustMap((sourceInstance) => {\n                return resolveEffectSource(this.errorHandler, this.effectsErrorHandler)(sourceInstance);\n            }), map((output) => {\n                reportInvalidActions(output, this.errorHandler);\n                return output.notification;\n            }), filter((notification) => notification.kind === 'N' && notification.value != null), dematerialize());\n            // start the stream with an INIT action\n            // do this only for the first Effect instance\n            const init$ = source$.pipe(take(1), filter(isOnInitEffects), map((instance) => instance.ngrxOnInitEffects()));\n            return merge(effect$, init$);\n        }));\n    }\n}\n/** @nocollapse */ EffectSources.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectSources, deps: [{ token: i0.ErrorHandler }, { token: EFFECTS_ERROR_HANDLER }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ EffectSources.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectSources, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectSources, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: i0.ErrorHandler }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [EFFECTS_ERROR_HANDLER]\n                }] }]; } });\nfunction effectsInstance(sourceInstance) {\n    if (isOnIdentifyEffects(sourceInstance)) {\n        return sourceInstance.ngrxOnIdentifyEffects();\n    }\n    return '';\n}\nfunction resolveEffectSource(errorHandler, effectsErrorHandler) {\n    return (sourceInstance) => {\n        const mergedEffects$ = mergeEffects(sourceInstance, errorHandler, effectsErrorHandler);\n        if (isOnRunEffects(sourceInstance)) {\n            return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n        }\n        return mergedEffects$;\n    };\n}\n\nclass EffectsRunner {\n    constructor(effectSources, store) {\n        this.effectSources = effectSources;\n        this.store = store;\n        this.effectsSubscription = null;\n    }\n    get isStarted() {\n        return !!this.effectsSubscription;\n    }\n    start() {\n        if (!this.effectsSubscription) {\n            this.effectsSubscription = this.effectSources\n                .toActions()\n                .subscribe(this.store);\n        }\n    }\n    ngOnDestroy() {\n        if (this.effectsSubscription) {\n            this.effectsSubscription.unsubscribe();\n            this.effectsSubscription = null;\n        }\n    }\n}\n/** @nocollapse */ EffectsRunner.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsRunner, deps: [{ token: EffectSources }, { token: i3.Store }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ EffectsRunner.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsRunner, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsRunner, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: EffectSources }, { type: i3.Store }]; } });\n\nclass EffectsRootModule {\n    constructor(sources, runner, store, rootEffects, storeRootModule, storeFeatureModule, guard) {\n        this.sources = sources;\n        runner.start();\n        rootEffects.forEach((effectSourceInstance) => sources.addEffects(effectSourceInstance));\n        store.dispatch({ type: ROOT_EFFECTS_INIT });\n    }\n    addEffects(effectSourceInstance) {\n        this.sources.addEffects(effectSourceInstance);\n    }\n}\n/** @nocollapse */ EffectsRootModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsRootModule, deps: [{ token: EffectSources }, { token: EffectsRunner }, { token: i3.Store }, { token: ROOT_EFFECTS }, { token: i3.StoreRootModule, optional: true }, { token: i3.StoreFeatureModule, optional: true }, { token: _ROOT_EFFECTS_GUARD, optional: true }], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ EffectsRootModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsRootModule });\n/** @nocollapse */ EffectsRootModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsRootModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsRootModule, decorators: [{\n            type: NgModule,\n            args: [{}]\n        }], ctorParameters: function () { return [{ type: EffectSources }, { type: EffectsRunner }, { type: i3.Store }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [ROOT_EFFECTS]\n                }] }, { type: i3.StoreRootModule, decorators: [{\n                    type: Optional\n                }] }, { type: i3.StoreFeatureModule, decorators: [{\n                    type: Optional\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [_ROOT_EFFECTS_GUARD]\n                }] }]; } });\n\nclass EffectsFeatureModule {\n    constructor(root, effectSourceGroups, storeRootModule, storeFeatureModule) {\n        effectSourceGroups.forEach((group) => group.forEach((effectSourceInstance) => root.addEffects(effectSourceInstance)));\n    }\n}\n/** @nocollapse */ EffectsFeatureModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsFeatureModule, deps: [{ token: EffectsRootModule }, { token: FEATURE_EFFECTS }, { token: i3.StoreRootModule, optional: true }, { token: i3.StoreFeatureModule, optional: true }], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ EffectsFeatureModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsFeatureModule });\n/** @nocollapse */ EffectsFeatureModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsFeatureModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsFeatureModule, decorators: [{\n            type: NgModule,\n            args: [{}]\n        }], ctorParameters: function () { return [{ type: EffectsRootModule }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [FEATURE_EFFECTS]\n                }] }, { type: i3.StoreRootModule, decorators: [{\n                    type: Optional\n                }] }, { type: i3.StoreFeatureModule, decorators: [{\n                    type: Optional\n                }] }]; } });\n\nclass EffectsModule {\n    static forFeature(featureEffects = []) {\n        return {\n            ngModule: EffectsFeatureModule,\n            providers: [\n                featureEffects,\n                {\n                    provide: _FEATURE_EFFECTS,\n                    multi: true,\n                    useValue: featureEffects,\n                },\n                {\n                    provide: USER_PROVIDED_EFFECTS,\n                    multi: true,\n                    useValue: [],\n                },\n                {\n                    provide: FEATURE_EFFECTS,\n                    multi: true,\n                    useFactory: createEffects,\n                    deps: [Injector, _FEATURE_EFFECTS, USER_PROVIDED_EFFECTS],\n                },\n            ],\n        };\n    }\n    static forRoot(rootEffects = []) {\n        return {\n            ngModule: EffectsRootModule,\n            providers: [\n                rootEffects,\n                {\n                    provide: _ROOT_EFFECTS,\n                    useValue: [rootEffects],\n                },\n                {\n                    provide: _ROOT_EFFECTS_GUARD,\n                    useFactory: _provideForRootGuard,\n                    deps: [\n                        [EffectsRunner, new Optional(), new SkipSelf()],\n                        [_ROOT_EFFECTS, new Self()],\n                    ],\n                },\n                {\n                    provide: USER_PROVIDED_EFFECTS,\n                    multi: true,\n                    useValue: [],\n                },\n                {\n                    provide: ROOT_EFFECTS,\n                    useFactory: createEffects,\n                    deps: [Injector, _ROOT_EFFECTS, USER_PROVIDED_EFFECTS],\n                },\n            ],\n        };\n    }\n}\n/** @nocollapse */ EffectsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ EffectsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsModule });\n/** @nocollapse */ EffectsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: EffectsModule, decorators: [{\n            type: NgModule,\n            args: [{}]\n        }] });\nfunction createEffects(injector, effectGroups, userProvidedEffectGroups) {\n    const mergedEffects = [];\n    for (const effectGroup of effectGroups) {\n        mergedEffects.push(...effectGroup);\n    }\n    for (const userProvidedEffectGroup of userProvidedEffectGroups) {\n        mergedEffects.push(...userProvidedEffectGroup);\n    }\n    return createEffectInstances(injector, mergedEffects);\n}\nfunction createEffectInstances(injector, effects) {\n    return effects.map((effect) => injector.get(effect));\n}\nfunction _provideForRootGuard(runner, rootEffects) {\n    // check whether any effects are actually passed\n    const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);\n    if (hasEffects && runner) {\n        throw new TypeError(`EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`);\n    }\n    return 'guarded';\n}\n\n/**\n * Wraps project fn with error handling making it safe to use in Effects.\n * Takes either a config with named properties that represent different possible\n * callbacks or project/error callbacks that are required.\n */\nfunction act(\n/** Allow to take either config object or project/error functions */\nconfigOrProject, errorFn) {\n    const { project, error, complete, operator, unsubscribe } = typeof configOrProject === 'function'\n        ? {\n            project: configOrProject,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            error: errorFn,\n            operator: concatMap,\n            complete: undefined,\n            unsubscribe: undefined,\n        }\n        : { ...configOrProject, operator: configOrProject.operator || concatMap };\n    return (source) => defer(() => {\n        const subject = new Subject();\n        return merge(source.pipe(operator((input, index) => defer(() => {\n            let completed = false;\n            let errored = false;\n            let projectedCount = 0;\n            return project(input, index).pipe(materialize(), map((notification) => {\n                switch (notification.kind) {\n                    case 'E':\n                        errored = true;\n                        return {\n                            kind: 'N',\n                            value: error(notification.error, input),\n                        };\n                    case 'C':\n                        completed = true;\n                        return complete\n                            ? {\n                                kind: 'N',\n                                value: complete(projectedCount, input),\n                            }\n                            : undefined;\n                    default:\n                        ++projectedCount;\n                        return notification;\n                }\n            }), filter((n) => n != null), dematerialize(), finalize(() => {\n                if (!completed && !errored && unsubscribe) {\n                    subject.next(unsubscribe(projectedCount, input));\n                }\n            }));\n        }))), subject);\n    });\n}\n\n/**\n * `concatLatestFrom` combines the source value\n * and the last available value from a lazily evaluated Observable\n * in a new array\n *\n * @usageNotes\n *\n * Select the active customer from the NgRx Store\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/effects';\n * import * as fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom(() => this.store.select(fromCustomers.selectActiveCustomer))\n * )\n * ```\n *\n * Select a customer from the NgRx Store by its id that is available on the action\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/effects';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom((action) => this.store.select(fromCustomers.selectCustomer(action.customerId)))\n * )\n * ```\n */\nfunction concatLatestFrom(observablesFactory) {\n    return pipe(concatMap((value) => {\n        const observables = observablesFactory(value);\n        const observablesAsArray = Array.isArray(observables)\n            ? observables\n            : [observables];\n        return of(value).pipe(withLatestFrom(...observablesAsArray));\n    }));\n}\n\n/**\n * Runs the provided effects.\n * Can be called at the root and feature levels.\n *\n * @usageNotes\n *\n * ### Providing effects at the root level\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [provideEffects([RouterEffects])],\n * });\n * ```\n *\n * ### Providing effects at the feature level\n *\n * ```ts\n * const booksRoutes: Route[] = [\n *   {\n *     path: '',\n *     providers: [provideEffects([BooksApiEffects])],\n *     children: [\n *       { path: '', component: BookListComponent },\n *       { path: ':id', component: BookDetailsComponent },\n *     ],\n *   },\n * ];\n * ```\n */\nfunction provideEffects(effects) {\n    return {\n        ɵproviders: [\n            effects,\n            {\n                provide: ENVIRONMENT_INITIALIZER,\n                multi: true,\n                useValue: () => {\n                    inject(ROOT_STORE_PROVIDER);\n                    inject(FEATURE_STATE_PROVIDER, InjectFlags.Optional);\n                    const effectsRunner = inject(EffectsRunner);\n                    const effectSources = inject(EffectSources);\n                    const shouldInitEffects = !effectsRunner.isStarted;\n                    if (shouldInitEffects) {\n                        effectsRunner.start();\n                    }\n                    for (const effectsClass of effects) {\n                        const effectsInstance = inject(effectsClass);\n                        effectSources.addEffects(effectsInstance);\n                    }\n                    if (shouldInitEffects) {\n                        const store = inject(Store);\n                        store.dispatch(rootEffectsInit());\n                    }\n                },\n            },\n        ],\n    };\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Actions, EFFECTS_ERROR_HANDLER, Effect, EffectSources, EffectsFeatureModule, EffectsModule, EffectsRootModule, EffectsRunner, ROOT_EFFECTS_INIT, USER_PROVIDED_EFFECTS, act, concatLatestFrom, createEffect, defaultEffectsErrorHandler, getEffectsMetadata, mergeEffects, ofType, provideEffects, rootEffectsInit };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}